#version 460

#extension GL_EXT_mesh_shader : require
#extension GL_GOOGLE_include_directive : enable

#include "../include/host_device.hpp"

layout(binding = 0, set = 0) readonly buffer CubeBuf {ObjData cubes[];};
layout(binding = 1, set = 0) uniform Ubo {MeshUbo ubo;};

layout (local_size_x = MESH_PER_TASK, local_size_y = 1, local_size_z = 1) in;

taskPayloadSharedEXT uint cubeBuffOffsets[MESH_PER_TASK];
shared bool meshPassed[MESH_PER_TASK];
/*

*/

void main()
{
    vec4 proj = ubo.projectionMatrix * ubo.viewMatrix * vec4(cubes[gl_GlobalInvocationID.x * CUBES_PER_MESH].pos.xyz, 1.0);
    proj /= proj.w;
    if (proj.x < -1.0 || proj.x > 1.0 || proj.y < -1.0 || proj.y > 1.0 || proj.z < 0.0 || proj.z > 1.0) meshPassed[gl_LocalInvocationID.x] = false;
    else {
        meshPassed[gl_LocalInvocationID.x] = true;
        cubeBuffOffsets[gl_LocalInvocationID.x] = gl_GlobalInvocationID.x * CUBES_PER_MESH * MESH_PER_CUBE;
    }
    if (gl_LocalInvocationIndex.x == 0) {
        uint index = 0;
        for (uint i = 0; i < MESH_PER_TASK; i++) {
            if (meshPassed[i]) {
                cubeBuffOffsets[index] = cubeBuffOffsets[i];
                index++;
            } 
        }
        EmitMeshTasksEXT(index, 1, 1);
    }
}
