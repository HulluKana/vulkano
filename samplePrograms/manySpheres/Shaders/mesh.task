#version 460

#extension GL_EXT_mesh_shader : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable



#include "../include/host_device.hpp"

layout(binding = 0, set = 0) uniform sampler2D depthImgs[];
layout(binding = 1, set = 0) readonly buffer CubeBuf {ObjData cubes[];};
layout(binding = 2, set = 0, scalar) readonly buffer ChunksBuf {ChunkData chunks[];};
layout(binding = 3, set = 0) uniform Ubo {MeshUbo ubo;};
layout(binding = 4, set = 0) writeonly uniform image2D debugImg;
layout(binding = 5, set = 0) writeonly buffer CullCounter {uint cullCount;};

layout (local_size_x = MESH_PER_TASK, local_size_y = 1, local_size_z = 1) in;

taskPayloadSharedEXT uint cubeBuffOffsets[MESH_PER_TASK];
shared bool meshPassed[MESH_PER_TASK];

void main()
{
    const mat4 projView = ubo.projectionMatrix * ubo.viewMatrix;
    const ChunkData chunk = chunks[gl_GlobalInvocationID.x];
    const vec4 corners[8] = {
        vec4(chunk.minPos.x, chunk.maxPos.y, chunk.maxPos.z, 1.0),
        vec4(chunk.maxPos.x, chunk.maxPos.y, chunk.maxPos.z, 1.0),
        vec4(chunk.maxPos.x, chunk.maxPos.y, chunk.minPos.z, 1.0),
        vec4(chunk.minPos.x, chunk.maxPos.y, chunk.minPos.z, 1.0),

        vec4(chunk.minPos.x, chunk.minPos.y, chunk.maxPos.z, 1.0),
        vec4(chunk.maxPos.x, chunk.minPos.y, chunk.maxPos.z, 1.0),
        vec4(chunk.maxPos.x, chunk.minPos.y, chunk.minPos.z, 1.0),
        vec4(chunk.minPos.x, chunk.minPos.y, chunk.minPos.z, 1.0)
    };

    bool allAhead = true;
    bool allBehind = true;
    bool allLeft = true;
    bool allRight = true;
    bool allUp = true;
    bool allDown = true;
    float minX = 69420.0;
    float maxX = -69420.0;
    float minY = 69420.0;
    float maxY = -69420.0;
    float minZ = 69420.0;
    for (uint i = 0; i < 8; i++) {
        vec4 corner = projView * corners[i];
        corner /= corner.w;
        allAhead = allAhead && corner.z > 1.0;
        allBehind = allBehind && corner.z < 0.0;
        allRight = allRight && corner.x > 1.0;
        allLeft = allLeft && corner.x < -1.0;
        allUp = allUp && corner.y > 1.0;
        allDown = allDown && corner.y < -1.0;

        minX = min(minX, corner.x);
        maxX = max(maxX, corner.x);
        minY = min(minY, corner.y);
        maxY = max(maxY, corner.y);
        minZ = min(minZ, corner.z);
    }

    bool isOccluded = false;
    if (minX >= -1.0 && maxX <= 1.0 && minY >= -1.0 && maxY <= 1.0) {
        const float cubeScreenWidth = (maxX - minX) * (float(ubo.screenDims.x) / 2.0);
        const float cubeScreenHeight = (maxY - minY) * (float(ubo.screenDims.y) / 2.0);
        const float depthImgLevel = floor(log2(max(cubeScreenWidth, cubeScreenHeight)));
        float depth = textureLod(depthImgs[ubo.depthImgIndex], (vec2(minX, minY) + vec2(1.0)) / 2.0, depthImgLevel).x;
        depth = max(textureLod(depthImgs[ubo.depthImgIndex], (vec2(minX, maxY) + vec2(1.0)) / 2.0, depthImgLevel).x, depth);
        depth = max(textureLod(depthImgs[ubo.depthImgIndex], (vec2(maxX, maxY) + vec2(1.0)) / 2.0, depthImgLevel).x, depth);
        depth = max(textureLod(depthImgs[ubo.depthImgIndex], (vec2(maxX, minY) + vec2(1.0)) / 2.0, depthImgLevel).x, depth);
        isOccluded = minZ > depth;
        if (isOccluded) atomicAdd(cullCount, 1);

/*
        for (int y = max(int((minY / 2.0 + 0.5) * float(ubo.screenDims.y)), 0); y < min(int((maxY / 2.0 + 0.5) * float(ubo.screenDims.y)), ubo.screenDims.y); y++) {
            for (int x = max(int((minX / 2.0 + 0.5) * float(ubo.screenDims.x)), 0); x < min(int((maxX / 2.0 + 0.5) * float(ubo.screenDims.x)), ubo.screenDims.x); x++) {
                imageStore(debugImg, ivec2(x, y), vec4(depth, depthImgLevel, minZ, 1.0));
            }
        }
        */
    }

    if (allAhead || allBehind || allRight || allLeft || allUp || allDown || isOccluded) meshPassed[gl_LocalInvocationID.x] = false;
    else {
        meshPassed[gl_LocalInvocationID.x] = true;
        cubeBuffOffsets[gl_LocalInvocationID.x] = gl_GlobalInvocationID.x * CUBES_PER_MESH * MESH_PER_CUBE;
    }
    if (gl_LocalInvocationIndex.x == 0) {
        uint index = 0;
        for (uint i = 0; i < MESH_PER_TASK; i++) {
            if (meshPassed[i]) {
                cubeBuffOffsets[index] = cubeBuffOffsets[i];
                index++;
            } 
        }
        EmitMeshTasksEXT(index, 1, 1);
    }
}
