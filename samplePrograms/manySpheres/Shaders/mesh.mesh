#version 460

#extension GL_EXT_mesh_shader : require
#extension GL_GOOGLE_include_directive : enable

#include "../include/host_device.hpp"

layout(binding = 0, set = 0) readonly buffer CubeBuf {ObjData cubes[];};
layout(binding = 1, set = 0) uniform Ubo {MeshUbo ubo;};

layout(local_size_x = MESH_PER_CUBE * CUBES_PER_MESH, local_size_y = 1, local_size_z = 1) in;
layout(triangles, max_vertices = CUBES_PER_MESH * 8, max_primitives = CUBES_PER_MESH * 12) out;

taskPayloadSharedEXT uint cubeBuffOffsets[MESH_PER_TASK];

layout (location = 0) out vec3 vertColors[CUBES_PER_MESH * 8];

void main()
{
    if (gl_LocalInvocationIndex.x == 0) SetMeshOutputsEXT(CUBES_PER_MESH * 8, CUBES_PER_MESH * 12);

    const mat4 projViewMat = ubo.projectionMatrix * ubo.viewMatrix;
    const vec4 cube = cubes[(gl_LocalInvocationID.x + cubeBuffOffsets[gl_WorkGroupID.x]) / MESH_PER_CUBE].pos;
    const vec3 color = cubes[(gl_LocalInvocationID.x + cubeBuffOffsets[gl_WorkGroupID.x]) / MESH_PER_CUBE].color.xyz;
    const uint vertexArrOffset = gl_LocalInvocationIndex.x * 8 / MESH_PER_CUBE;
    const uint primArrOffset = gl_LocalInvocationIndex.x * 12 / MESH_PER_CUBE;
    const uint cubeHalf = gl_LocalInvocationIndex.x % MESH_PER_CUBE; // 1 is bottom, 0 is top

    /*
        An illustration of a cube
          0---1
         /|  /|
        3---2 |
        | | | |
        | 4-|-5
        |/  |/
        7---6
    */

    gl_MeshVerticesEXT[vertexArrOffset + 0].gl_Position = projViewMat * vec4(cube.xyz + vec3(-0.5,  0.5 - cubeHalf,  0.5) * cube.w, 1.0);
    gl_MeshVerticesEXT[vertexArrOffset + 1].gl_Position = projViewMat * vec4(cube.xyz + vec3( 0.5,  0.5 - cubeHalf,  0.5) * cube.w, 1.0);
    gl_MeshVerticesEXT[vertexArrOffset + 2].gl_Position = projViewMat * vec4(cube.xyz + vec3( 0.5,  0.5 - cubeHalf, -0.5) * cube.w, 1.0);
    gl_MeshVerticesEXT[vertexArrOffset + 3].gl_Position = projViewMat * vec4(cube.xyz + vec3(-0.5,  0.5 - cubeHalf, -0.5) * cube.w, 1.0);

    vertColors[vertexArrOffset + 0] = color;
    vertColors[vertexArrOffset + 1] = color;
    vertColors[vertexArrOffset + 2] = color;
    vertColors[vertexArrOffset + 3] = color;

    const uint alignedVertexArrOffset = vertexArrOffset / 8 * 8;

    // right or left
    gl_PrimitiveTriangleIndicesEXT[primArrOffset + 0] = uvec3(ivec3(1, 5, 6) + ivec3(-1, -1, 1) * cubeHalf) + uvec3(alignedVertexArrOffset);
    gl_PrimitiveTriangleIndicesEXT[primArrOffset + 1] = uvec3(ivec3(6, 2, 1) + ivec3(-1, -1, 1) * cubeHalf) + uvec3(alignedVertexArrOffset);
    // top or bottom
    gl_PrimitiveTriangleIndicesEXT[primArrOffset + 2] = uvec3(0, 1, 2) + uvec3(vertexArrOffset);
    gl_PrimitiveTriangleIndicesEXT[primArrOffset + 3] = uvec3(2, 3, 0) + uvec3(vertexArrOffset);
    // front or back
    gl_PrimitiveTriangleIndicesEXT[primArrOffset + 4] = uvec3(0, 1, 5) + uvec3(alignedVertexArrOffset) + uvec3(3, 1, 1) * cubeHalf;
    gl_PrimitiveTriangleIndicesEXT[primArrOffset + 5] = uvec3(5, 4, 0) + uvec3(alignedVertexArrOffset) + uvec3(1, 3, 3) * cubeHalf;

    /*
    // right
    gl_PrimitiveTriangleIndicesEXT[primArrOffset + 0] = uvec3(1, 5, 6) + uvec3(vertexArrOffset);
    gl_PrimitiveTriangleIndicesEXT[primArrOffset + 1] = uvec3(6, 2, 1) + uvec3(vertexArrOffset);
    // left
    gl_PrimitiveTriangleIndicesEXT[primArrOffset + 2] = uvec3(0, 4, 7) + uvec3(vertexArrOffset);
    gl_PrimitiveTriangleIndicesEXT[primArrOffset + 3] = uvec3(7, 3, 0) + uvec3(vertexArrOffset);
    // top
    gl_PrimitiveTriangleIndicesEXT[primArrOffset + 4] = uvec3(0, 1, 2) + uvec3(vertexArrOffset);
    gl_PrimitiveTriangleIndicesEXT[primArrOffset + 5] = uvec3(2, 3, 0) + uvec3(vertexArrOffset);
    // bottom
    gl_PrimitiveTriangleIndicesEXT[primArrOffset + 6] = uvec3(4, 5, 6) + uvec3(vertexArrOffset);
    gl_PrimitiveTriangleIndicesEXT[primArrOffset + 7] = uvec3(6, 7, 4) + uvec3(vertexArrOffset);
    // front
    gl_PrimitiveTriangleIndicesEXT[primArrOffset + 8] = uvec3(0, 1, 5) + uvec3(vertexArrOffset);
    gl_PrimitiveTriangleIndicesEXT[primArrOffset + 9] = uvec3(5, 4, 0) + uvec3(vertexArrOffset);
    // back
    gl_PrimitiveTriangleIndicesEXT[primArrOffset + 10] = uvec3(3, 2, 6) + uvec3(vertexArrOffset);
    gl_PrimitiveTriangleIndicesEXT[primArrOffset + 11] = uvec3(6, 7, 3) + uvec3(vertexArrOffset);
    */
}
