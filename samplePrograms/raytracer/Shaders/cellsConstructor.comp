#version 460

#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable

#include "common.glsl"
#include "../include/host_device.hpp"

layout(binding = 10, set = 0, scalar) buffer ReservoirsBuffers  {ivec4 minPos; uvec4 dims; Reservoir data[];} reservoirs[RESERVOIR_HISTORY_LEN];
layout(binding = 11, set = 0, scalar) buffer CellData  {Cell cells[];};
layout(binding = 12, set = 0, r32ui) readonly uniform uimage3D hitCache;

layout(push_constant) uniform Push{uint frameNumber;};

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

void main()
{
    const uvec3 dims = reservoirs[0].dims.xyz;
    const uvec3 cellCoord = gl_GlobalInvocationID;
    if (cellCoord.x >= dims.x || cellCoord.y >= dims.y || cellCoord.z >= dims.z) return;
    if (imageLoad(hitCache, ivec3(cellCoord)).x < frameNumber - RESERVOIR_HISTORY_LEN) return;

    const uint cellIdx = (cellCoord.z * dims.y * dims.x + cellCoord.y * dims.x + cellCoord.x);
    const uint resIdx = cellIdx * RESERVOIRS_PER_CELL;
    const uint histIdx = frameNumber % RESERVOIR_HISTORY_LEN;

    struct Sample {
        uint idx;
        float weight;
    };
    uint samplesIdx = 0;
    uint workSamplesIdx = 1;
    Sample samples[2][RESERVOIRS_PER_CELL];
    float avgOfAllReservoirs = 0.0;
    float avgPdf = 0.0;
    for (uint i = 0; i < RESERVOIRS_PER_CELL; i++) {
        const Reservoir reservoir = reservoirs[histIdx].data[resIdx + i];
        avgOfAllReservoirs += reservoir.averageWeight;
        avgPdf += reservoir.targetPdf;
        samples[samplesIdx][i].idx = i;
        samples[samplesIdx][i].weight = reservoir.targetPdf;
    }
    avgPdf /= float(RESERVOIRS_PER_CELL);

    for (uint width = 1; width < RESERVOIRS_PER_CELL; width *= 2) {
        for (uint j = 0; j < RESERVOIRS_PER_CELL; j += width * 2) {
            const uint cLeft = j;
            const uint cRight = j + width;
            const uint cEnd = j + 2 * width;
            uint left = cLeft;
            uint right = cRight;
            for (uint k = cLeft; k < cEnd; k++) {
                if (samples[samplesIdx][left].weight >= samples[samplesIdx][right].weight) {
                    samples[workSamplesIdx][k] = samples[samplesIdx][left]; 
                    left++;
                    continue;
                }
                samples[workSamplesIdx][k] = samples[samplesIdx][right];
                right++;
            }
        }

        workSamplesIdx = samplesIdx;
        samplesIdx = (samplesIdx + 1) % 2;
    }

    for (uint i = 0; i < RESERVOIRS_PER_CELL - 1; i++) {
        Alias alias;
        alias.sample1 = samples[samplesIdx][RESERVOIRS_PER_CELL - i - 1].idx;
        alias.sample2 = samples[samplesIdx][0].idx;
        alias.threshold = samples[samplesIdx][RESERVOIRS_PER_CELL - i - 1].weight / avgPdf;
        cells[cellIdx].aliasTable[i] = alias;

        samples[samplesIdx][0].weight -= avgPdf - samples[samplesIdx][RESERVOIRS_PER_CELL - i - 1].weight;

        const Sample insertable = samples[samplesIdx][0];
        for (uint j = 0; j < RESERVOIRS_PER_CELL - 2 - i; j++) {
            const Sample sampl = samples[samplesIdx][j + 1];
            if (sampl.weight <= insertable.weight) {
                samples[samplesIdx][j] = insertable;
                break;
            }
            samples[samplesIdx][j] = samples[samplesIdx][j + 1];
        }
    }

    Alias alias;
    alias.sample1 = samples[samplesIdx][0].idx;
    alias.sample2 = samples[samplesIdx][0].idx;
    alias.threshold = 1.0;
    cells[cellIdx].aliasTable[RESERVOIRS_PER_CELL - 1] = alias;

    cells[cellIdx].avgReservoirWeight = avgOfAllReservoirs / float(RESERVOIRS_PER_CELL);
}
