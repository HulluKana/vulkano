#version 460

#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable

#include "common.glsl"
#include "../include/host_device.hpp"
#include"../../../essentials/include/vul_scene.hpp"

layout(binding = 9, set = 0) readonly buffer LightInfos         {LightInfo lightInfos[];};
layout(binding = 10, set = 0, scalar) buffer ReservoirsBuffers  {ivec4 minPos; uvec4 dims; Reservoir data[];} reservoirs[RESERVOIR_HISTORY_LEN];
layout(binding = 11, set = 0, r32ui) readonly uniform uimage3D hitCache;

layout(push_constant) uniform Push{uint frameNumber;};

layout(local_size_x = RESERVOIRS_PER_CELL, local_size_y = 1, local_size_z = 1) in;

uint randomUint(inout uint state)
{
    state = state * 747796405 + 2891336453;
    uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
    result = (result >> 22) ^ result;
    return result;
};

float randomFloat(inout uint state)
{
    return float(randomUint(state)) / 4294967295.0;
};

void main()
{
    const uvec3 cellCoord = gl_WorkGroupID;
    const ivec3 minPos = reservoirs[0].minPos.xyz;
    const uvec3 dims = reservoirs[0].dims.xyz;
    const int x = int(cellCoord.x) + minPos.x;
    const int y = int(cellCoord.y) + minPos.y;
    const int z = int(cellCoord.z) + minPos.z;
    if (imageLoad(hitCache, ivec3(cellCoord)).x < frameNumber - RESERVOIR_HISTORY_LEN) return;

    const uint BAD_SAMPLES = 32;
    const float CELL_SIZE = 1.0;
    const uint reservoirIdx = (cellCoord.z * dims.y * dims.x + cellCoord.y * dims.x + cellCoord.x) * RESERVOIRS_PER_CELL + gl_LocalInvocationID.x;
    uint state = reservoirIdx * frameNumber;
    const uint lightCount = lightInfos.length();
    Reservoir reservoir;
    for (uint i = 0; i < BAD_SAMPLES; i++) {
        const uint idx = randomUint(state) % lightCount;
        const LightInfo light = lightInfos[idx]; 
        const float sourcePdf = 1.0 / float(lightCount);

        const float lightXDiff = max(light.position.x - x, CELL_SIZE * 0.5);
        const float lightYDiff = max(light.position.y - y, CELL_SIZE * 0.5);
        const float lightZDiff = max(light.position.z - z, CELL_SIZE * 0.5);
        const float lightStrength = sRGBToAlbedo((light.color.x + light.color.y + light.color.z) * light.color.w / 3.0);
        const float targetPdf = lightStrength / (lightXDiff * lightXDiff + lightYDiff * lightYDiff + lightZDiff * lightZDiff) / lightInfos.length();

        const float risWeight = targetPdf / sourcePdf;
        reservoir.averageWeight += risWeight;
        if (randomFloat(state) < risWeight / reservoir.averageWeight) {
            reservoir.lightIdx = idx;
            reservoir.targetPdf = targetPdf;
        }
    }

    for (uint i = 1; i < RESERVOIR_HISTORY_LEN; i++) {
        Reservoir oldReservoir = reservoirs[(frameNumber + i) % RESERVOIR_HISTORY_LEN].data[reservoirIdx];
        if (oldReservoir.averageWeight < 0.01) {
            oldReservoir.averageWeight = reservoir.averageWeight / float(BAD_SAMPLES);
            oldReservoir.lightIdx = reservoir.lightIdx;
            oldReservoir.targetPdf = reservoir.targetPdf;
            reservoirs[(frameNumber + i) % RESERVOIR_HISTORY_LEN].data[reservoirIdx] = oldReservoir;
        }
    }

    reservoir.averageWeight /= float(BAD_SAMPLES);
    for (uint i = 1; i < RESERVOIR_HISTORY_LEN; i++) {
        Reservoir oldReservoir = reservoirs[(frameNumber + i) % RESERVOIR_HISTORY_LEN].data[reservoirIdx];
        reservoir.averageWeight += oldReservoir.averageWeight;
        if (randomFloat(state) < oldReservoir.averageWeight / reservoir.averageWeight) {
            reservoir.lightIdx = oldReservoir.lightIdx;
            reservoir.targetPdf = oldReservoir.targetPdf;
        }
        reservoir.averageWeight /= 2.0;
    }
    reservoirs[frameNumber % RESERVOIR_HISTORY_LEN].data[reservoirIdx] = reservoir;
}
