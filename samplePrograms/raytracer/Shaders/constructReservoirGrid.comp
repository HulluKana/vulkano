#version 460

#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_ray_query : enable

#include "common.glsl"
#include "../include/host_device.hpp"
#include"../../../essentials/include/vul_scene.hpp"

layout(binding = 0, set = 0) readonly buffer LightInfos         {LightInfo lightInfos[];};
layout(binding = 1, set = 0, scalar) buffer ReservoirsBuffers  {ivec4 minPos; uvec4 dims; Reservoir data[];} reservoirs[RESERVOIR_HISTORY_LEN];
layout(binding = 3, set = 0, r32ui) readonly uniform uimage3D hitCache;
layout(binding = 4, set = 0) uniform accelerationStructureEXT tlas;

layout(push_constant) uniform Push{uint frameNumber;};

layout(local_size_x = RESERVOIRS_PER_CELL, local_size_y = 1, local_size_z = 1) in;

void main()
{
    const uint cullStartFrameNumber = 128;

    const uvec3 cellCoord = gl_WorkGroupID;
    if (frameNumber >= cullStartFrameNumber && imageLoad(hitCache, ivec3(cellCoord)).x < frameNumber - RESERVOIR_HISTORY_LEN) return;

    const uint BAD_SAMPLES = 32;
    const float CELL_SIZE = 1.0;
    const uvec3 dims = reservoirs[0].dims.xyz;
    const uint reservoirIdx = (cellCoord.z * dims.y * dims.x + cellCoord.y * dims.x + cellCoord.x) * RESERVOIRS_PER_CELL + gl_LocalInvocationID.x;
    uint state = reservoirIdx * frameNumber;
    const uint lightCount = lightInfos.length();

    const ivec3 minPos = reservoirs[0].minPos.xyz;
    const int x = int(cellCoord.x) + minPos.x;
    const int y = int(cellCoord.y) + minPos.y;
    const int z = int(cellCoord.z) + minPos.z;
    const vec3 pos = vec3(x, y, z) + (vec3(randomFloat(state), randomFloat(state), randomFloat(state)) * 2.0 - 1.0) * CELL_SIZE * 0.5;

    Reservoir reservoir;
    reservoir.lightIdx = 0;
    reservoir.averageWeight = 0.0;
    reservoir.targetPdf = 0.0;
    float selectedRisWeight = 0.0;
    for (uint i = 0; i < BAD_SAMPLES; i++) {
        const uint idx = randomUint(state) % lightCount;
        const LightInfo light = lightInfos[idx]; 
        const float sourcePdf = 1.0 / float(lightCount);

        const float lightXDiff = max(abs(light.position.x - pos.x), CELL_SIZE * 0.5);
        const float lightYDiff = max(abs(light.position.y - pos.y), CELL_SIZE * 0.5);
        const float lightZDiff = max(abs(light.position.z - pos.z), CELL_SIZE * 0.5);
        const float lightStrength = sRGBToAlbedo((light.color.x + light.color.y + light.color.z) * light.color.w / 3.0);
        const float targetPdf = lightStrength / (lightXDiff * lightXDiff + lightYDiff * lightYDiff + lightZDiff * lightZDiff) / lightCount;

        const float risWeight = targetPdf / sourcePdf;
        reservoir.averageWeight += risWeight;
        if (randomFloat(state) < risWeight / reservoir.averageWeight) {
            reservoir.lightIdx = idx;
            reservoir.targetPdf = targetPdf;
            selectedRisWeight = risWeight;
        }
    }

    vec3 dir = lightInfos[reservoir.lightIdx].position.xyz - pos;
    const float tMin = 0.001;
    const float tMax = length(dir);
    dir = normalize(dir);
    rayQueryEXT rayQuery;
    rayQueryInitializeEXT(rayQuery, tlas, gl_RayFlagsTerminateOnFirstHitEXT, 0xff, pos, tMin, dir, tMax);
    while(rayQueryProceedEXT(rayQuery));
    if(rayQueryGetIntersectionTypeEXT(rayQuery, true) != gl_RayQueryCommittedIntersectionNoneEXT) {
        reservoir.targetPdf *= 0.001;
        reservoir.averageWeight -= selectedRisWeight;
    }

    for (uint i = 1; i < RESERVOIR_HISTORY_LEN; i++) {
        Reservoir oldReservoir = reservoirs[(frameNumber + i) % RESERVOIR_HISTORY_LEN].data[reservoirIdx];
        if (oldReservoir.averageWeight < 0.0001) {
            oldReservoir.averageWeight = reservoir.averageWeight / float(BAD_SAMPLES);
            oldReservoir.lightIdx = reservoir.lightIdx;
            oldReservoir.targetPdf = reservoir.targetPdf;
            reservoirs[(frameNumber + i) % RESERVOIR_HISTORY_LEN].data[reservoirIdx] = oldReservoir;
        }
    }

    reservoir.averageWeight /= float(BAD_SAMPLES);
    for (uint i = 1; i < RESERVOIR_HISTORY_LEN; i++) {
        Reservoir oldReservoir = reservoirs[(frameNumber + i) % RESERVOIR_HISTORY_LEN].data[reservoirIdx];
        reservoir.averageWeight += oldReservoir.averageWeight;
        if (randomFloat(state) < oldReservoir.averageWeight / reservoir.averageWeight) {
            reservoir.lightIdx = oldReservoir.lightIdx;
            reservoir.targetPdf = oldReservoir.targetPdf;
        }
        reservoir.averageWeight /= 2.0;
    }
    reservoirs[frameNumber % RESERVOIR_HISTORY_LEN].data[reservoirIdx] = reservoir;
}
